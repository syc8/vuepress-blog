<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js基础知识 | sansu-blog</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="技术博客">
    
    <link rel="preload" href="/assets/css/0.styles.9f84806b.css" as="style"><link rel="preload" href="/assets/js/app.220fcdf5.js" as="script"><link rel="preload" href="/assets/js/2.778bb4ad.js" as="script"><link rel="preload" href="/assets/js/1.50b457b8.js" as="script"><link rel="preload" href="/assets/js/25.c0c326b8.js" as="script"><link rel="prefetch" href="/assets/js/10.325b9f09.js"><link rel="prefetch" href="/assets/js/11.c62b6b34.js"><link rel="prefetch" href="/assets/js/12.ecdb524b.js"><link rel="prefetch" href="/assets/js/13.52087e05.js"><link rel="prefetch" href="/assets/js/14.eb7a3d07.js"><link rel="prefetch" href="/assets/js/15.114dfd5c.js"><link rel="prefetch" href="/assets/js/16.85253907.js"><link rel="prefetch" href="/assets/js/17.c2838453.js"><link rel="prefetch" href="/assets/js/18.3256f17f.js"><link rel="prefetch" href="/assets/js/19.d8afd0ae.js"><link rel="prefetch" href="/assets/js/20.10e47ab9.js"><link rel="prefetch" href="/assets/js/21.33b300c9.js"><link rel="prefetch" href="/assets/js/22.b7c97fbe.js"><link rel="prefetch" href="/assets/js/23.3fe4f4e7.js"><link rel="prefetch" href="/assets/js/24.1b1a526d.js"><link rel="prefetch" href="/assets/js/26.d196432d.js"><link rel="prefetch" href="/assets/js/27.0237ff6e.js"><link rel="prefetch" href="/assets/js/28.ff559d07.js"><link rel="prefetch" href="/assets/js/29.8ea4d81b.js"><link rel="prefetch" href="/assets/js/3.af33e5d6.js"><link rel="prefetch" href="/assets/js/30.eb86d065.js"><link rel="prefetch" href="/assets/js/31.a0ccb169.js"><link rel="prefetch" href="/assets/js/32.84503ad3.js"><link rel="prefetch" href="/assets/js/33.ac4015e6.js"><link rel="prefetch" href="/assets/js/34.96388a70.js"><link rel="prefetch" href="/assets/js/35.69d0b815.js"><link rel="prefetch" href="/assets/js/36.467f6d59.js"><link rel="prefetch" href="/assets/js/37.63d0c8ba.js"><link rel="prefetch" href="/assets/js/38.b62fd785.js"><link rel="prefetch" href="/assets/js/4.45665f8a.js"><link rel="prefetch" href="/assets/js/5.7098d77a.js"><link rel="prefetch" href="/assets/js/6.0c0a0f39.js"><link rel="prefetch" href="/assets/js/7.6a854e57.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9f84806b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">sansu-blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">面试题</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">面试题</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/2023专项复习/" class="nav-link">
  2023专项复习
</a></li><li class="dropdown-item"><!----> <a href="/interview/手写题/" class="nav-link">
  手写题
</a></li><li class="dropdown-item"><!----> <a href="/interview/输出打印题/" class="nav-link">
  输出打印题
</a></li><li class="dropdown-item"><!----> <a href="/interview/虚拟列表/" class="nav-link">
  虚拟列表
</a></li><li class="dropdown-item"><!----> <a href="/interview/2020面试题1/" class="nav-link">
  2020面试题1
</a></li><li class="dropdown-item"><!----> <a href="/interview/2020面试题2/" class="nav-link">
  2020面试题2
</a></li><li class="dropdown-item"><!----> <a href="/interview/覆盘/" class="nav-link">
  覆盘
</a></li><li class="dropdown-item"><!----> <a href="/interview/性能优化/" class="nav-link">
  性能优化
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">微信小程序</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">微信小程序</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wechatmini/小程序.html" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/wechatmini/01小程序_技术选型.html" class="nav-link">
  01小程序技术选型
</a></li><li class="dropdown-item"><!----> <a href="/wechatmini/02微信小程序-系统实践学习.html" class="nav-link">
  02原生微信小程序实践
</a></li><li class="dropdown-item"><!----> <a href="/wechatmini/WePY - 快速开发小程序.html" class="nav-link">
  WePY快速开发
</a></li></ul></div></div><div class="nav-item"><a href="/document/index/" class="nav-link">
  文档
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">react</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">react</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/react/R/" class="nav-link">
  R
</a></li><li class="dropdown-item"><!----> <a href="/react/React+nextjs访问星/" class="nav-link">
  React+nextjs访问星
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/syc-xiaosu03" target="_self" class="nav-link external">
  github
  <!----></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">面试题</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">面试题</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/2023专项复习/" class="nav-link">
  2023专项复习
</a></li><li class="dropdown-item"><!----> <a href="/interview/手写题/" class="nav-link">
  手写题
</a></li><li class="dropdown-item"><!----> <a href="/interview/输出打印题/" class="nav-link">
  输出打印题
</a></li><li class="dropdown-item"><!----> <a href="/interview/虚拟列表/" class="nav-link">
  虚拟列表
</a></li><li class="dropdown-item"><!----> <a href="/interview/2020面试题1/" class="nav-link">
  2020面试题1
</a></li><li class="dropdown-item"><!----> <a href="/interview/2020面试题2/" class="nav-link">
  2020面试题2
</a></li><li class="dropdown-item"><!----> <a href="/interview/覆盘/" class="nav-link">
  覆盘
</a></li><li class="dropdown-item"><!----> <a href="/interview/性能优化/" class="nav-link">
  性能优化
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">微信小程序</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">微信小程序</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wechatmini/小程序.html" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/wechatmini/01小程序_技术选型.html" class="nav-link">
  01小程序技术选型
</a></li><li class="dropdown-item"><!----> <a href="/wechatmini/02微信小程序-系统实践学习.html" class="nav-link">
  02原生微信小程序实践
</a></li><li class="dropdown-item"><!----> <a href="/wechatmini/WePY - 快速开发小程序.html" class="nav-link">
  WePY快速开发
</a></li></ul></div></div><div class="nav-item"><a href="/document/index/" class="nav-link">
  文档
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">react</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">react</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/react/R/" class="nav-link">
  R
</a></li><li class="dropdown-item"><!----> <a href="/react/React+nextjs访问星/" class="nav-link">
  React+nextjs访问星
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/syc-xiaosu03" target="_self" class="nav-link external">
  github
  <!----></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>js基础知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#js基础知识" class="sidebar-link">js基础知识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#原型与原型链" class="sidebar-link">原型与原型链</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#构造-原型-实例-之间关系" class="sidebar-link">构造，原型，实例 之间关系</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#es6新特性" class="sidebar-link">es6新特性</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#dom事件和事件流" class="sidebar-link">DOM事件和事件流</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#盒子模型" class="sidebar-link">盒子模型</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#bfc" class="sidebar-link">BFC</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#flex" class="sidebar-link">Flex</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#promise原理以及手写代码" class="sidebar-link">Promise原理以及手写代码</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#http缓存机制" class="sidebar-link">HTTP缓存机制</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#webpack" class="sidebar-link">webpack</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#event-loop-事件循环" class="sidebar-link">event loop 事件循环</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#vue3解决什么问题" class="sidebar-link">vue3解决什么问题</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#vue-为什么不能检测数组和对象的变化-怎么处理-为什么通过索引操作数组不能触发响应式" class="sidebar-link">Vue 为什么不能检测数组和对象的变化,怎么处理(为什么通过索引操作数组不能触发响应式)</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#vue-router原理" class="sidebar-link">vue router原理</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#v-model实现原理" class="sidebar-link">v-model实现原理</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#vue-nexttick" class="sidebar-link">vue.nexttick</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#" class="sidebar-link"></a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#mvvm" class="sidebar-link">MVVM</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#mvc" class="sidebar-link">MVC</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#promise-基本上要求可以手写promise-all方法-这个问的最多" class="sidebar-link">promise(基本上要求可以手写Promise.all方法,这个问的最多)</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#async-await" class="sidebar-link">async/await</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#跨域形成原因以及解决方案" class="sidebar-link">跨域形成原因以及解决方案</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#箭头函数和普通函数有什么区别" class="sidebar-link">箭头函数和普通函数有什么区别</a></li><li class="sidebar-sub-header"><a href="/interview/2020%E9%9D%A2%E8%AF%95%E9%A2%982.html#最近在看什么新技术" class="sidebar-link">最近在看什么新技术</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="js基础知识"><a href="#js基础知识" class="header-anchor">#</a> js基础知识</h2> <h3 id="原型与原型链"><a href="#原型与原型链" class="header-anchor">#</a> 原型与原型链</h3> <h4 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h4> <ul><li><p>函数也是对象，任何一个函数中都有一个 prototype 属性，也是一个对象，即 原型对象</p></li> <li><p>该对象的所以成员， 都可以被 其构造函数的 实例对象访问</p></li></ul> <h4 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h4> <blockquote><p>使用构造函数新建对象后， 内部会包含一个指针： <code>_ proto _</code>   这个属性就相当于一个链，指向了构造函数的prototype属性，串联起来了原型链</p></blockquote> <ul><li><p>浏览器中现在支持显示的使用 <strong>proto</strong> 属性，但不推荐(不是规范中规定的)</p></li> <li><p>ES5 中新增了一个 <code>Object.getPrototypeOf()</code> 方法，我们可以通过这个方法来获取对 象的原型。</p></li></ul> <p><strong>当我们访问一个对象的属性时 ( 查找规则就是原型链的概念 )</strong></p> <ol><li>先在自己身上找， 没有就去它的原型对象里找</li> <li>若没有，继续侧沿着原型链向上找</li> <li>最终到达 Object.prototype，上查找</li> <li>若没有，则找到 Object.prototype. _ proto _ 这里是 null,也是原型链的终点</li></ol> <blockquote><p>原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。</p></blockquote> <h3 id="构造-原型-实例-之间关系"><a href="#构造-原型-实例-之间关系" class="header-anchor">#</a> 构造，原型，实例 之间关系</h3> <ul><li><p>实例对象的 _ proto _     -----指向 ------    原型对象（即构造函数的原型）</p> <blockquote><p>new Person. _ proto _  指向   Person.prototype</p></blockquote></li> <li><p>实例对象的 constructor     -----指向------   构造函数</p> <blockquote><p>new Person. _ constructor   指向   function Person()</p></blockquote></li> <li><p>原型对象的 constructor      -----指向----      构造函数</p> <blockquote><p>Person.prototype .constructor  指向  function Person()</p></blockquote></li> <li><p>new 构造函数     -----等于-----     实例</p></li></ul> <h3 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h3> <ol><li><h5 id="原型链继承-将子类的原型-指向父类的实例"><a href="#原型链继承-将子类的原型-指向父类的实例" class="header-anchor">#</a> 原型链继承：  将子类的原型 指向父类的实例</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Son</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> New <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>注意：</p> <ul><li>简单易用</li> <li>但子类新增方法各成员必须在 <strong>用原型 继承父类实例 之后</strong></li></ul></li> <li><h5 id="构造继承-子类通过-call-复制父类的成功给子类"><a href="#构造继承-子类通过-call-复制父类的成功给子类" class="header-anchor">#</a> 构造继承：  子类通过 call  复制父类的成功给子类</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> son <span class="token operator">=</span> New <span class="token function">Son</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
</code></pre></div><p>注意：</p> <ul><li>可以实现多继承（call多个父类对象）</li> <li>只能继承父类构造函数的成员，不可继承父类原型的成员</li> <li>实例并不是父类的实例，只是子类的实例</li> <li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li></ul></li> <li><h5 id="实例继承-为-父类实例-添加新特性-并把-父类实例-作为-子类实例-return-返回"><a href="#实例继承-为-父类实例-添加新特性-并把-父类实例-作为-子类实例-return-返回" class="header-anchor">#</a> 实例继承： 为 <strong>父类实例</strong> 添加新特性，并把 <strong>父类实例</strong> 作为 <strong>子类实例</strong> return 返回</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> sonInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    sonInstance<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">''</span>
    sonInstance<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token string">''</span>
    <span class="token operator">...</span><span class="token punctuation">.</span>
    
    <span class="token keyword">return</span> sonInstance
<span class="token punctuation">}</span>
<span class="token keyword">var</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><h5 id="拷贝继承-利用循环-从父类构造的实例上拷贝-到子类原型上-来实现继承"><a href="#拷贝继承-利用循环-从父类构造的实例上拷贝-到子类原型上-来实现继承" class="header-anchor">#</a> 拷贝继承： 利用循环，从<strong>父类构造的实例上拷贝</strong>  到子类原型上 来实现继承</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> father <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> p <span class="token keyword">in</span> father<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">Son</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> father<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Test Code</span>
<span class="token keyword">var</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son <span class="token keyword">instanceof</span> <span class="token class-name">Father</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son <span class="token keyword">instanceof</span> <span class="token class-name">Son</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div></li> <li><h5 id="组合继承-相当与-1原型链继承-与-2构造继承-结合使用"><a href="#组合继承-相当与-1原型链继承-与-2构造继承-结合使用" class="header-anchor">#</a> 组合继承： 相当与 1原型链继承 与 2构造继承 结合使用</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> New <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 组合继承也是需要修复构造函数指向的。</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Son
<span class="token keyword">var</span> son <span class="token operator">=</span> New <span class="token function">Son</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>寄生组件继承： 通过寄生的方式来修复组合式继承的不足，完美的实现继承</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//父类</span>
<span class="token keyword">function</span> <span class="token function">People</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'wangxiao'</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age <span class="token operator">||</span> <span class="token number">27</span>
<span class="token punctuation">}</span>
<span class="token comment">//父类方法</span>
<span class="token class-name">People</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token string">'eat sleep'</span>
<span class="token punctuation">}</span>
<span class="token comment">//子类</span>
<span class="token keyword">function</span> <span class="token function">Woman</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//继承父类属性</span>
  <span class="token function">People</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">//继承父类方法</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 创建空类</span>
  <span class="token keyword">let</span> <span class="token function-variable function">Super</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 将空类的原型，指向父类的原型</span>
  <span class="token class-name">Super</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">People</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token comment">// 子类的原型 再指向 父类的实例</span>
  <span class="token class-name">Woman</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//修复构造函数指向问题</span>
<span class="token class-name">Woman</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Woman<span class="token punctuation">;</span>
<span class="token keyword">let</span> womanObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <h3 id="es6新特性"><a href="#es6新特性" class="header-anchor">#</a> es6新特性</h3> <h3 id="dom事件和事件流"><a href="#dom事件和事件流" class="header-anchor">#</a> DOM事件和事件流</h3> <h3 id="盒子模型"><a href="#盒子模型" class="header-anchor">#</a> 盒子模型</h3> <h3 id="bfc"><a href="#bfc" class="header-anchor">#</a> BFC</h3> <h3 id="flex"><a href="#flex" class="header-anchor">#</a> Flex</h3> <h3 id="promise原理以及手写代码"><a href="#promise原理以及手写代码" class="header-anchor">#</a> Promise原理以及手写代码</h3> <h3 id="http缓存机制"><a href="#http缓存机制" class="header-anchor">#</a> HTTP缓存机制</h3> <ul><li><p>强制缓存</p> <blockquote><p>一般我们网站中的css,js等资源会用强制缓存，（其文件名中跟随hash版本号的话，如果已经更新，通过文件名就可以判断版本号）</p></blockquote></li> <li><p>协商缓存</p> <blockquote><p>一般我们网站中的html文档，因为更新的机率大一些，使用协商缓存询问比较好</p></blockquote></li></ul> <h1 id="面试中遇到的高频题-跟上面会有重合"><a href="#面试中遇到的高频题-跟上面会有重合" class="header-anchor">#</a> 面试中遇到的高频题(跟上面会有重合)</h1> <h3 id="webpack"><a href="#webpack" class="header-anchor">#</a> webpack</h3> <p>打包流程</p> <blockquote><ol><li>解析配置文件：Webpack 会读取并解析配置文件（通常是 <code>webpack.config.js</code> 文件），并根据配置生成一个 Compiler 对象。</li> <li>读取入口文件：Webpack 根据配置中的入口文件，读取这些文件及其依赖的模块，并将它们组成一个依赖图。</li> <li>解析模块依赖：Webpack 会根据模块之间的依赖关系，递归地解析它们的依赖，直到所有的依赖都被解析完毕。</li> <li>加载模块：Webpack 会根据模块的路径，使用相应的 Loader 加载模块的源代码，并将其转换为 Webpack 可以处理的形式。</li> <li>转换代码：Webpack 会根据配置中的插件，对加载的模块进行一系列的转换操作，比如压缩、合并、优化等。</li> <li>生成代码：Webpack 会将所有模块转换后的代码合并成一个或多个文件，并输出到指定的输出目录中。</li></ol></blockquote> <h3 id="event-loop-事件循环"><a href="#event-loop-事件循环" class="header-anchor">#</a> event loop 事件循环</h3> <blockquote><p>js代码执行基于一种事件循环机制，会先执行主进程代码，异步代码分别放到执行队列内</p></blockquote> <p>异步任务分为两种，宏任务和微任务</p> <ul><li><p>微任务 micro （顺序=优先级）</p> <ul><li>process.next回调</li> <li>promise.then()</li></ul></li> <li><p>宏任务 macro （顺序=优先级）</p> <ul><li>setTimeOut</li> <li>readFile回调 （只在nodejs有）</li> <li>setImmediate</li> <li>socket.close 回调 （只在nodejs有）</li></ul></li></ul> <h5 id="执行顺序"><a href="#执行顺序" class="header-anchor">#</a> 执行顺序：</h5> <blockquote><p>执行主进程代码 --&gt;  异步微任务 ---&gt; 异步宏任务   ---&gt; 微任务 ---&gt; 宏任务。。。。</p></blockquote> <h5 id="浏览器和-node-环境下-microtask-任务队列的执行时机不同"><a href="#浏览器和-node-环境下-microtask-任务队列的执行时机不同" class="header-anchor">#</a> 浏览器和 Node 环境下，microtask 任务队列的执行时机不同</h5> <ul><li>Node 端，microtask 在事件循环的各个阶段之间执行，<em><strong>node每次执行宏任务会执行所有的</strong></em></li> <li>浏览器端，microtask 在事件循环的<em>各个宏任务</em> macrotask 执行完之后执行，<em><strong>浏览器每次只执行一个宏任务就会去执行微任务</strong></em></li></ul> <h3 id="vue3解决什么问题"><a href="#vue3解决什么问题" class="header-anchor">#</a> vue3解决什么问题</h3> <h3 id="vue-为什么不能检测数组和对象的变化-怎么处理-为什么通过索引操作数组不能触发响应式"><a href="#vue-为什么不能检测数组和对象的变化-怎么处理-为什么通过索引操作数组不能触发响应式" class="header-anchor">#</a> Vue 为什么不能检测数组和对象的变化,怎么处理(为什么通过索引操作数组不能触发响应式)</h3> <h3 id="vue-router原理"><a href="#vue-router原理" class="header-anchor">#</a> vue router原理</h3> <h3 id="v-model实现原理"><a href="#v-model实现原理" class="header-anchor">#</a> v-model实现原理</h3> <p>本身只是一个语法糖，原理是依靠</p> <ul><li>用 v-bind 编写响应式数据</li> <li>触发 oninput 事件并传递数据</li></ul> <h3 id="vue-nexttick"><a href="#vue-nexttick" class="header-anchor">#</a> vue.nexttick</h3> <h3 id=""><a href="#" class="header-anchor">#</a></h3> <h3 id="mvvm"><a href="#mvvm" class="header-anchor">#</a> MVVM</h3> <p>M数据模型层： M 改变会引起 VM自动更新，View也会自动变化</p> <p>V视图层：V 变化， 也会自动反映在 ViewModel</p> <p>VM 调度者：  <strong>提供了数据的双向绑定</strong>，实时改变数据状态，及页面反馈</p> <blockquote><p>MVVM<strong>主要解决了MVC中大量的DOM操作使页面</strong>渲染性能降低，加载速度变慢，影响用户体验。</p></blockquote> <img src="https://img2018.cnblogs.com/blog/1404918/201902/1404918-20190219115337118-140425768.png" alt="img" style="zoom:80%;"> <h3 id="mvc"><a href="#mvc" class="header-anchor">#</a> MVC</h3> <p>V视图层:  页面行为会传送到 C</p> <p>c 控制器：C 去通知 Model改变状态， <strong>都是单向通信</strong></p> <p>M数据层：Model将新的数据 发送到View, 用户得到反馈</p> <blockquote><p>Model与VIew是完全隔离的，由 Controller 来处理二者间的交互，同时这三者也都是<strong>完全独立分开的，所有通信都是单向的</strong></p></blockquote> <p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png" alt="img"></p> <h3 id="promise-基本上要求可以手写promise-all方法-这个问的最多"><a href="#promise-基本上要求可以手写promise-all方法-这个问的最多" class="header-anchor">#</a> promise(基本上要求可以手写Promise.all方法,这个问的最多)</h3> <p>promist.all:  将多个promise对象包装成一个，成功时返回一个结果数组，失败时返回最先失败的状态值</p> <p>promise.race:  也是将多个promise实例包装成一个实例执行，不管结果成功与失败，只返回最快等到结果的那个</p> <h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> async/await</h3> <blockquote><p>是一个以同步思维解决异步问题的方案(等结果出来代码才往下执行)，优化了promise的使用方式，减少了链式调用</p> <p>基于Promise, 并且借助于 Promise 在async函数中，使用 await 获取 Promise 异步函数的 resolve 状态下返回的数据</p></blockquote> <p>async： 关键字，用来定义一个异步函数，并且返回这个 promise对象(是基于promise的)</p> <ul><li>async异步函数存在.then方法，可以指定的回调函数</li> <li>并且只有在 async函数内的异步执行完，才会执行 .then方法里的回调</li> <li>async异步函数的内部也可以使用await关键字</li></ul> <p>await: 	关键定，用于等待一个 promise 对象, <strong>只能在 async 异步函数中使用</strong></p> <ul><li>await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数。</li> <li>await 将等待 Promise 正常处理完成并返回其处理结果</li> <li>async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 假设一个promise异步操作</span>
<span class="token keyword">function</span> <span class="token function">testAwait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;testAwait&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义 async异步函数</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 遇到 await 就会先暂停执行</span>
    <span class="token comment">// 等到触发的异步操作完成后</span>
    <span class="token keyword">await</span> <span class="token function">textAwait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 恢复 async 函数的执行并返回解析值</span>
<span class="token punctuation">}</span>
<span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="跨域形成原因以及解决方案"><a href="#跨域形成原因以及解决方案" class="header-anchor">#</a> 跨域形成原因以及解决方案</h3> <h3 id="箭头函数和普通函数有什么区别"><a href="#箭头函数和普通函数有什么区别" class="header-anchor">#</a> 箭头函数和普通函数有什么区别</h3> <ul><li>写法不同</li> <li>全是匿名函数</li> <li>不可以使用new</li> <li>没有prototype原型对象</li> <li>this指向不同</li></ul> <h3 id="最近在看什么新技术"><a href="#最近在看什么新技术" class="header-anchor">#</a> 最近在看什么新技术</h3> <h1 id="低频但是需要注意的面试题"><a href="#低频但是需要注意的面试题" class="header-anchor">#</a> 低频但是需要注意的面试题</h1> <ul><li>CSRF &amp; XSS</li> <li>chrome设置小于12px字体</li> <li>node和浏览器事件循环有何不同</li> <li>webpack tree shaking</li> <li>map &amp; set</li> <li>前端有哪些技术(腾讯面试题,面试官会顺着你说的技术一个一个展开问)</li> <li>实现一个call/bind(call,apply,bind区别)</li> <li>get 和 post 的区别</li> <li>BFC</li> <li>yield</li> <li>如何给localStorage加上max-age功能</li> <li>Object.defineProperties都有那些参数,以及参数解释</li> <li>requestAnimation</li> <li>手写原型链和js各种继承模式</li> <li>让你重新做你做过的项目有什么可以改进的地方</li> <li>让一个元素消失的几种做法，有何不同，对子元素的影响</li> <li>如何遍历对象(接下来会问有何不同)</li> <li>搜索框输入需要注意的点(其实还是在问防抖)</li> <li>原生实现inserAfter</li> <li>事件委托应用场景，e.target和e.currentTarget区别</li> <li>HTTP缓存，对应字段，cache-contron都有那些值</li> <li>new过程都发生了什么</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.220fcdf5.js" defer></script><script src="/assets/js/2.778bb4ad.js" defer></script><script src="/assets/js/1.50b457b8.js" defer></script><script src="/assets/js/25.c0c326b8.js" defer></script>
  </body>
</html>
